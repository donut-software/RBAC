// Code generated by counterfeiter. DO NOT EDIT.
package resttesting

import (
	"context"
	"rbac/internal"
	"rbac/internal/rest"
	"sync"
)

type FakeRBACService struct {
	AccountStub        func(context.Context, string) (internal.Account, error)
	accountMutex       sync.RWMutex
	accountArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	accountReturns struct {
		result1 internal.Account
		result2 error
	}
	accountReturnsOnCall map[int]struct {
		result1 internal.Account
		result2 error
	}
	ChangePasswordStub        func(context.Context, string, string) error
	changePasswordMutex       sync.RWMutex
	changePasswordArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	changePasswordReturns struct {
		result1 error
	}
	changePasswordReturnsOnCall map[int]struct {
		result1 error
	}
	CreateAccountStub        func(context.Context, internal.Account, string) error
	createAccountMutex       sync.RWMutex
	createAccountArgsForCall []struct {
		arg1 context.Context
		arg2 internal.Account
		arg3 string
	}
	createAccountReturns struct {
		result1 error
	}
	createAccountReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAccountStub        func(context.Context, string) error
	deleteAccountMutex       sync.RWMutex
	deleteAccountArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteAccountReturns struct {
		result1 error
	}
	deleteAccountReturnsOnCall map[int]struct {
		result1 error
	}
	ListAccountStub        func(context.Context, internal.ListAccountArgs) (internal.ListAccount, error)
	listAccountMutex       sync.RWMutex
	listAccountArgsForCall []struct {
		arg1 context.Context
		arg2 internal.ListAccountArgs
	}
	listAccountReturns struct {
		result1 internal.ListAccount
		result2 error
	}
	listAccountReturnsOnCall map[int]struct {
		result1 internal.ListAccount
		result2 error
	}
	UpdateProfileStub        func(context.Context, internal.Profile) error
	updateProfileMutex       sync.RWMutex
	updateProfileArgsForCall []struct {
		arg1 context.Context
		arg2 internal.Profile
	}
	updateProfileReturns struct {
		result1 error
	}
	updateProfileReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRBACService) Account(arg1 context.Context, arg2 string) (internal.Account, error) {
	fake.accountMutex.Lock()
	ret, specificReturn := fake.accountReturnsOnCall[len(fake.accountArgsForCall)]
	fake.accountArgsForCall = append(fake.accountArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.AccountStub
	fakeReturns := fake.accountReturns
	fake.recordInvocation("Account", []interface{}{arg1, arg2})
	fake.accountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRBACService) AccountCallCount() int {
	fake.accountMutex.RLock()
	defer fake.accountMutex.RUnlock()
	return len(fake.accountArgsForCall)
}

func (fake *FakeRBACService) AccountCalls(stub func(context.Context, string) (internal.Account, error)) {
	fake.accountMutex.Lock()
	defer fake.accountMutex.Unlock()
	fake.AccountStub = stub
}

func (fake *FakeRBACService) AccountArgsForCall(i int) (context.Context, string) {
	fake.accountMutex.RLock()
	defer fake.accountMutex.RUnlock()
	argsForCall := fake.accountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRBACService) AccountReturns(result1 internal.Account, result2 error) {
	fake.accountMutex.Lock()
	defer fake.accountMutex.Unlock()
	fake.AccountStub = nil
	fake.accountReturns = struct {
		result1 internal.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeRBACService) AccountReturnsOnCall(i int, result1 internal.Account, result2 error) {
	fake.accountMutex.Lock()
	defer fake.accountMutex.Unlock()
	fake.AccountStub = nil
	if fake.accountReturnsOnCall == nil {
		fake.accountReturnsOnCall = make(map[int]struct {
			result1 internal.Account
			result2 error
		})
	}
	fake.accountReturnsOnCall[i] = struct {
		result1 internal.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeRBACService) ChangePassword(arg1 context.Context, arg2 string, arg3 string) error {
	fake.changePasswordMutex.Lock()
	ret, specificReturn := fake.changePasswordReturnsOnCall[len(fake.changePasswordArgsForCall)]
	fake.changePasswordArgsForCall = append(fake.changePasswordArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ChangePasswordStub
	fakeReturns := fake.changePasswordReturns
	fake.recordInvocation("ChangePassword", []interface{}{arg1, arg2, arg3})
	fake.changePasswordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRBACService) ChangePasswordCallCount() int {
	fake.changePasswordMutex.RLock()
	defer fake.changePasswordMutex.RUnlock()
	return len(fake.changePasswordArgsForCall)
}

func (fake *FakeRBACService) ChangePasswordCalls(stub func(context.Context, string, string) error) {
	fake.changePasswordMutex.Lock()
	defer fake.changePasswordMutex.Unlock()
	fake.ChangePasswordStub = stub
}

func (fake *FakeRBACService) ChangePasswordArgsForCall(i int) (context.Context, string, string) {
	fake.changePasswordMutex.RLock()
	defer fake.changePasswordMutex.RUnlock()
	argsForCall := fake.changePasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRBACService) ChangePasswordReturns(result1 error) {
	fake.changePasswordMutex.Lock()
	defer fake.changePasswordMutex.Unlock()
	fake.ChangePasswordStub = nil
	fake.changePasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRBACService) ChangePasswordReturnsOnCall(i int, result1 error) {
	fake.changePasswordMutex.Lock()
	defer fake.changePasswordMutex.Unlock()
	fake.ChangePasswordStub = nil
	if fake.changePasswordReturnsOnCall == nil {
		fake.changePasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.changePasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRBACService) CreateAccount(arg1 context.Context, arg2 internal.Account, arg3 string) error {
	fake.createAccountMutex.Lock()
	ret, specificReturn := fake.createAccountReturnsOnCall[len(fake.createAccountArgsForCall)]
	fake.createAccountArgsForCall = append(fake.createAccountArgsForCall, struct {
		arg1 context.Context
		arg2 internal.Account
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateAccountStub
	fakeReturns := fake.createAccountReturns
	fake.recordInvocation("CreateAccount", []interface{}{arg1, arg2, arg3})
	fake.createAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRBACService) CreateAccountCallCount() int {
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	return len(fake.createAccountArgsForCall)
}

func (fake *FakeRBACService) CreateAccountCalls(stub func(context.Context, internal.Account, string) error) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = stub
}

func (fake *FakeRBACService) CreateAccountArgsForCall(i int) (context.Context, internal.Account, string) {
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	argsForCall := fake.createAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRBACService) CreateAccountReturns(result1 error) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = nil
	fake.createAccountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRBACService) CreateAccountReturnsOnCall(i int, result1 error) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = nil
	if fake.createAccountReturnsOnCall == nil {
		fake.createAccountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createAccountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRBACService) DeleteAccount(arg1 context.Context, arg2 string) error {
	fake.deleteAccountMutex.Lock()
	ret, specificReturn := fake.deleteAccountReturnsOnCall[len(fake.deleteAccountArgsForCall)]
	fake.deleteAccountArgsForCall = append(fake.deleteAccountArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteAccountStub
	fakeReturns := fake.deleteAccountReturns
	fake.recordInvocation("DeleteAccount", []interface{}{arg1, arg2})
	fake.deleteAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRBACService) DeleteAccountCallCount() int {
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	return len(fake.deleteAccountArgsForCall)
}

func (fake *FakeRBACService) DeleteAccountCalls(stub func(context.Context, string) error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = stub
}

func (fake *FakeRBACService) DeleteAccountArgsForCall(i int) (context.Context, string) {
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	argsForCall := fake.deleteAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRBACService) DeleteAccountReturns(result1 error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = nil
	fake.deleteAccountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRBACService) DeleteAccountReturnsOnCall(i int, result1 error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = nil
	if fake.deleteAccountReturnsOnCall == nil {
		fake.deleteAccountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAccountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRBACService) ListAccount(arg1 context.Context, arg2 internal.ListAccountArgs) (internal.ListAccount, error) {
	fake.listAccountMutex.Lock()
	ret, specificReturn := fake.listAccountReturnsOnCall[len(fake.listAccountArgsForCall)]
	fake.listAccountArgsForCall = append(fake.listAccountArgsForCall, struct {
		arg1 context.Context
		arg2 internal.ListAccountArgs
	}{arg1, arg2})
	stub := fake.ListAccountStub
	fakeReturns := fake.listAccountReturns
	fake.recordInvocation("ListAccount", []interface{}{arg1, arg2})
	fake.listAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRBACService) ListAccountCallCount() int {
	fake.listAccountMutex.RLock()
	defer fake.listAccountMutex.RUnlock()
	return len(fake.listAccountArgsForCall)
}

func (fake *FakeRBACService) ListAccountCalls(stub func(context.Context, internal.ListAccountArgs) (internal.ListAccount, error)) {
	fake.listAccountMutex.Lock()
	defer fake.listAccountMutex.Unlock()
	fake.ListAccountStub = stub
}

func (fake *FakeRBACService) ListAccountArgsForCall(i int) (context.Context, internal.ListAccountArgs) {
	fake.listAccountMutex.RLock()
	defer fake.listAccountMutex.RUnlock()
	argsForCall := fake.listAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRBACService) ListAccountReturns(result1 internal.ListAccount, result2 error) {
	fake.listAccountMutex.Lock()
	defer fake.listAccountMutex.Unlock()
	fake.ListAccountStub = nil
	fake.listAccountReturns = struct {
		result1 internal.ListAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeRBACService) ListAccountReturnsOnCall(i int, result1 internal.ListAccount, result2 error) {
	fake.listAccountMutex.Lock()
	defer fake.listAccountMutex.Unlock()
	fake.ListAccountStub = nil
	if fake.listAccountReturnsOnCall == nil {
		fake.listAccountReturnsOnCall = make(map[int]struct {
			result1 internal.ListAccount
			result2 error
		})
	}
	fake.listAccountReturnsOnCall[i] = struct {
		result1 internal.ListAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeRBACService) UpdateProfile(arg1 context.Context, arg2 internal.Profile) error {
	fake.updateProfileMutex.Lock()
	ret, specificReturn := fake.updateProfileReturnsOnCall[len(fake.updateProfileArgsForCall)]
	fake.updateProfileArgsForCall = append(fake.updateProfileArgsForCall, struct {
		arg1 context.Context
		arg2 internal.Profile
	}{arg1, arg2})
	stub := fake.UpdateProfileStub
	fakeReturns := fake.updateProfileReturns
	fake.recordInvocation("UpdateProfile", []interface{}{arg1, arg2})
	fake.updateProfileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRBACService) UpdateProfileCallCount() int {
	fake.updateProfileMutex.RLock()
	defer fake.updateProfileMutex.RUnlock()
	return len(fake.updateProfileArgsForCall)
}

func (fake *FakeRBACService) UpdateProfileCalls(stub func(context.Context, internal.Profile) error) {
	fake.updateProfileMutex.Lock()
	defer fake.updateProfileMutex.Unlock()
	fake.UpdateProfileStub = stub
}

func (fake *FakeRBACService) UpdateProfileArgsForCall(i int) (context.Context, internal.Profile) {
	fake.updateProfileMutex.RLock()
	defer fake.updateProfileMutex.RUnlock()
	argsForCall := fake.updateProfileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRBACService) UpdateProfileReturns(result1 error) {
	fake.updateProfileMutex.Lock()
	defer fake.updateProfileMutex.Unlock()
	fake.UpdateProfileStub = nil
	fake.updateProfileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRBACService) UpdateProfileReturnsOnCall(i int, result1 error) {
	fake.updateProfileMutex.Lock()
	defer fake.updateProfileMutex.Unlock()
	fake.UpdateProfileStub = nil
	if fake.updateProfileReturnsOnCall == nil {
		fake.updateProfileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateProfileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRBACService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.accountMutex.RLock()
	defer fake.accountMutex.RUnlock()
	fake.changePasswordMutex.RLock()
	defer fake.changePasswordMutex.RUnlock()
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	fake.listAccountMutex.RLock()
	defer fake.listAccountMutex.RUnlock()
	fake.updateProfileMutex.RLock()
	defer fake.updateProfileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRBACService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rest.RBACService = new(FakeRBACService)
